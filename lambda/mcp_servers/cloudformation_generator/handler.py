"""
MCP Server - CloudFormation Template Generation
Generates professional CloudFormation templates based on project requirements
"""

import json
import boto3
import os
import uuid
from datetime import datetime
from typing import Dict, Any, List

def lambda_handler(event, context):
    """Generate CloudFormation templates based on project information"""
    try:
        project_info = event.get('project_info', {})
        agent_response = event.get('agent_response', '')
        
        print(f"Generating CloudFormation template for: {project_info.get('name', 'Unknown')}")
        
        # Generate CloudFormation template
        template = generate_cloudformation_template(project_info, agent_response)
        
        return {
            'template': template,
            'generated_at': datetime.now().isoformat(),
            'project_name': project_info.get('name', 'AWS Project')
        }
        
    except Exception as e:
        print(f"Error in CloudFormation generator: {str(e)}")
        return {'error': str(e)}

def generate_cloudformation_template(project_info: Dict[str, Any], agent_response: str) -> Dict[str, Any]:
    """Generate CloudFormation template based on project requirements"""
    
    project_name = project_info.get('name', 'AWSProject').replace(' ', '')
    solution_type = project_info.get('solution_type', 'integral')
    services = project_info.get('selected_services', [])
    
    # Base template structure
    template = {
        'AWSTemplateFormatVersion': '2010-09-09',
        'Description': f'CloudFormation template for {project_name} - Generated by AWS Propuestas V3',
        'Parameters': _generate_parameters(project_info),
        'Resources': {},
        'Outputs': {}
    }
    
    # Add resources based on solution type and services
    if solution_type == 'rapid_service':
        template['Resources'].update(_generate_rapid_service_resources(services, project_name))
    else:
        template['Resources'].update(_generate_integral_solution_resources(project_info, project_name))
    
    # Add common resources
    template['Resources'].update(_generate_common_resources(project_name))
    
    # Generate outputs
    template['Outputs'] = _generate_outputs(template['Resources'], project_name)
    
    return {
        'filename': f"{project_name}_CloudFormation_Template.yaml",
        'content': _convert_to_yaml_string(template),
        'template_dict': template,
        'description': f'CloudFormation template for {project_name}'
    }

def _generate_parameters(project_info: Dict[str, Any]) -> Dict[str, Any]:
    """Generate CloudFormation parameters"""
    return {
        'Environment': {
            'Type': 'String',
            'Default': 'prod',
            'AllowedValues': ['dev', 'staging', 'prod'],
            'Description': 'Environment name'
        },
        'ProjectName': {
            'Type': 'String',
            'Default': project_info.get('name', 'AWSProject').replace(' ', ''),
            'Description': 'Name of the project'
        }
    }

def _generate_rapid_service_resources(services: List[str], project_name: str) -> Dict[str, Any]:
    """Generate resources for rapid services"""
    resources = {}
    
    # VPC (always include for networking)
    resources.update(_generate_vpc_resources(project_name))
    
    # Add service-specific resources
    for service in services:
        if service == 'EC2':
            resources.update(_generate_ec2_resources(project_name))
        elif service == 'RDS':
            resources.update(_generate_rds_resources(project_name))
        elif service == 'S3':
            resources.update(_generate_s3_resources(project_name))
        elif service == 'ELB':
            resources.update(_generate_elb_resources(project_name))
        elif service == 'CloudFront':
            resources.update(_generate_cloudfront_resources(project_name))
    
    return resources

def _generate_integral_solution_resources(project_info: Dict[str, Any], project_name: str) -> Dict[str, Any]:
    """Generate resources for integral solutions"""
    resources = {}
    
    solution_detail = project_info.get('solution_type_detail', '').lower()
    
    # Always include VPC for enterprise solutions
    resources.update(_generate_vpc_resources(project_name))
    
    if 'web' in solution_detail or 'aplicacion' in solution_detail:
        resources.update(_generate_web_application_resources(project_name))
    elif 'data' in solution_detail or 'analitica' in solution_detail:
        resources.update(_generate_data_analytics_resources(project_name))
    elif 'iot' in solution_detail:
        resources.update(_generate_iot_resources(project_name))
    else:
        resources.update(_generate_general_enterprise_resources(project_name))
    
    return resources

def _generate_vpc_resources(project_name: str) -> Dict[str, Any]:
    """Generate VPC and networking resources"""
    return {
        f'{project_name}VPC': {
            'Type': 'AWS::EC2::VPC',
            'Properties': {
                'CidrBlock': '10.0.0.0/16',
                'EnableDnsHostnames': True,
                'EnableDnsSupport': True,
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-VPC'}}
                ]
            }
        },
        f'{project_name}InternetGateway': {
            'Type': 'AWS::EC2::InternetGateway',
            'Properties': {
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-IGW'}}
                ]
            }
        },
        f'{project_name}AttachGateway': {
            'Type': 'AWS::EC2::VPCGatewayAttachment',
            'Properties': {
                'VpcId': {'Ref': f'{project_name}VPC'},
                'InternetGatewayId': {'Ref': f'{project_name}InternetGateway'}
            }
        },
        f'{project_name}PublicSubnet1': {
            'Type': 'AWS::EC2::Subnet',
            'Properties': {
                'VpcId': {'Ref': f'{project_name}VPC'},
                'CidrBlock': '10.0.1.0/24',
                'AvailabilityZone': {'Fn::Select': [0, {'Fn::GetAZs': ''}]},
                'MapPublicIpOnLaunch': True,
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-Public-Subnet-1'}}
                ]
            }
        },
        f'{project_name}PublicSubnet2': {
            'Type': 'AWS::EC2::Subnet',
            'Properties': {
                'VpcId': {'Ref': f'{project_name}VPC'},
                'CidrBlock': '10.0.2.0/24',
                'AvailabilityZone': {'Fn::Select': [1, {'Fn::GetAZs': ''}]},
                'MapPublicIpOnLaunch': True,
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-Public-Subnet-2'}}
                ]
            }
        },
        f'{project_name}PrivateSubnet1': {
            'Type': 'AWS::EC2::Subnet',
            'Properties': {
                'VpcId': {'Ref': f'{project_name}VPC'},
                'CidrBlock': '10.0.10.0/24',
                'AvailabilityZone': {'Fn::Select': [0, {'Fn::GetAZs': ''}]},
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-Private-Subnet-1'}}
                ]
            }
        },
        f'{project_name}PrivateSubnet2': {
            'Type': 'AWS::EC2::Subnet',
            'Properties': {
                'VpcId': {'Ref': f'{project_name}VPC'},
                'CidrBlock': '10.0.20.0/24',
                'AvailabilityZone': {'Fn::Select': [1, {'Fn::GetAZs': ''}]},
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-Private-Subnet-2'}}
                ]
            }
        }
    }

def _generate_ec2_resources(project_name: str) -> Dict[str, Any]:
    """Generate EC2 resources"""
    return {
        f'{project_name}SecurityGroup': {
            'Type': 'AWS::EC2::SecurityGroup',
            'Properties': {
                'GroupDescription': f'Security group for {project_name} EC2 instances',
                'VpcId': {'Ref': f'{project_name}VPC'},
                'SecurityGroupIngress': [
                    {
                        'IpProtocol': 'tcp',
                        'FromPort': 80,
                        'ToPort': 80,
                        'CidrIp': '0.0.0.0/0'
                    },
                    {
                        'IpProtocol': 'tcp',
                        'FromPort': 443,
                        'ToPort': 443,
                        'CidrIp': '0.0.0.0/0'
                    }
                ],
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-SG'}}
                ]
            }
        },
        f'{project_name}LaunchTemplate': {
            'Type': 'AWS::EC2::LaunchTemplate',
            'Properties': {
                'LaunchTemplateName': {'Fn::Sub': '${ProjectName}-LaunchTemplate'},
                'LaunchTemplateData': {
                    'ImageId': 'ami-0c02fb55956c7d316',  # Amazon Linux 2
                    'InstanceType': 't3.micro',
                    'SecurityGroupIds': [{'Ref': f'{project_name}SecurityGroup'}],
                    'UserData': {
                        'Fn::Base64': {
                            'Fn::Sub': '''#!/bin/bash
yum update -y
yum install -y httpd
systemctl start httpd
systemctl enable httpd
echo "<h1>Welcome to ${ProjectName}</h1>" > /var/www/html/index.html
'''
                        }
                    },
                    'TagSpecifications': [
                        {
                            'ResourceType': 'instance',
                            'Tags': [
                                {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-Instance'}}
                            ]
                        }
                    ]
                }
            }
        }
    }

def _generate_rds_resources(project_name: str) -> Dict[str, Any]:
    """Generate RDS resources"""
    return {
        f'{project_name}DBSubnetGroup': {
            'Type': 'AWS::RDS::DBSubnetGroup',
            'Properties': {
                'DBSubnetGroupDescription': f'Subnet group for {project_name} database',
                'SubnetIds': [
                    {'Ref': f'{project_name}PrivateSubnet1'},
                    {'Ref': f'{project_name}PrivateSubnet2'}
                ],
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-DB-SubnetGroup'}}
                ]
            }
        },
        f'{project_name}DBSecurityGroup': {
            'Type': 'AWS::EC2::SecurityGroup',
            'Properties': {
                'GroupDescription': f'Security group for {project_name} database',
                'VpcId': {'Ref': f'{project_name}VPC'},
                'SecurityGroupIngress': [
                    {
                        'IpProtocol': 'tcp',
                        'FromPort': 3306,
                        'ToPort': 3306,
                        'SourceSecurityGroupId': {'Ref': f'{project_name}SecurityGroup'}
                    }
                ],
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-DB-SG'}}
                ]
            }
        },
        f'{project_name}Database': {
            'Type': 'AWS::RDS::DBInstance',
            'Properties': {
                'DBInstanceIdentifier': {'Fn::Sub': '${ProjectName}-database'},
                'DBInstanceClass': 'db.t3.micro',
                'Engine': 'mysql',
                'EngineVersion': '8.0',
                'AllocatedStorage': 20,
                'StorageType': 'gp2',
                'DBSubnetGroupName': {'Ref': f'{project_name}DBSubnetGroup'},
                'VPCSecurityGroups': [{'Ref': f'{project_name}DBSecurityGroup'}],
                'MasterUsername': 'admin',
                'MasterUserPassword': {'Fn::Sub': '${ProjectName}Password123!'},
                'BackupRetentionPeriod': 7,
                'MultiAZ': False,
                'StorageEncrypted': True,
                'DeletionProtection': False,
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-Database'}}
                ]
            }
        }
    }

def _generate_s3_resources(project_name: str) -> Dict[str, Any]:
    """Generate S3 resources"""
    return {
        f'{project_name}S3Bucket': {
            'Type': 'AWS::S3::Bucket',
            'Properties': {
                'BucketName': {'Fn::Sub': '${ProjectName}-${Environment}-${AWS::AccountId}'},
                'VersioningConfiguration': {
                    'Status': 'Enabled'
                },
                'BucketEncryption': {
                    'ServerSideEncryptionConfiguration': [
                        {
                            'ServerSideEncryptionByDefault': {
                                'SSEAlgorithm': 'AES256'
                            }
                        }
                    ]
                },
                'PublicAccessBlockConfiguration': {
                    'BlockPublicAcls': True,
                    'BlockPublicPolicy': True,
                    'IgnorePublicAcls': True,
                    'RestrictPublicBuckets': True
                },
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-S3-Bucket'}}
                ]
            }
        }
    }

def _generate_common_resources(project_name: str) -> Dict[str, Any]:
    """Generate common resources for monitoring and security"""
    return {
        f'{project_name}CloudWatchLogGroup': {
            'Type': 'AWS::Logs::LogGroup',
            'Properties': {
                'LogGroupName': {'Fn::Sub': '/aws/${ProjectName}/${Environment}'},
                'RetentionInDays': 14
            }
        }
    }

def _generate_outputs(resources: Dict[str, Any], project_name: str) -> Dict[str, Any]:
    """Generate CloudFormation outputs"""
    outputs = {}
    
    # VPC outputs
    if f'{project_name}VPC' in resources:
        outputs['VPCId'] = {
            'Description': 'VPC ID',
            'Value': {'Ref': f'{project_name}VPC'},
            'Export': {'Name': {'Fn::Sub': '${AWS::StackName}-VPC-ID'}}
        }
    
    # Database outputs
    if f'{project_name}Database' in resources:
        outputs['DatabaseEndpoint'] = {
            'Description': 'Database endpoint',
            'Value': {'Fn::GetAtt': [f'{project_name}Database', 'Endpoint.Address']},
            'Export': {'Name': {'Fn::Sub': '${AWS::StackName}-DB-Endpoint'}}
        }
    
    # S3 outputs
    if f'{project_name}S3Bucket' in resources:
        outputs['S3BucketName'] = {
            'Description': 'S3 bucket name',
            'Value': {'Ref': f'{project_name}S3Bucket'},
            'Export': {'Name': {'Fn::Sub': '${AWS::StackName}-S3-Bucket'}}
        }
    
    return outputs

def _convert_to_yaml_string(template: Dict[str, Any]) -> str:
    """Convert CloudFormation template to YAML string"""
    import yaml
    
    # Custom YAML representer for CloudFormation functions
    def represent_dict(dumper, data):
        return dumper.represent_dict(data.items())
    
    yaml.add_representer(dict, represent_dict)
    
    # Convert to YAML with proper formatting
    yaml_content = yaml.dump(
        template,
        default_flow_style=False,
        indent=2,
        width=120,
        allow_unicode=True
    )
    
    return yaml_content

# Additional resource generators for integral solutions
def _generate_web_application_resources(project_name: str) -> Dict[str, Any]:
    """Generate resources for web applications"""
    resources = {}
    resources.update(_generate_ec2_resources(project_name))
    resources.update(_generate_rds_resources(project_name))
    resources.update(_generate_s3_resources(project_name))
    resources.update(_generate_elb_resources(project_name))
    return resources

def _generate_elb_resources(project_name: str) -> Dict[str, Any]:
    """Generate Application Load Balancer resources"""
    return {
        f'{project_name}ALB': {
            'Type': 'AWS::ElasticLoadBalancingV2::LoadBalancer',
            'Properties': {
                'Name': {'Fn::Sub': '${ProjectName}-ALB'},
                'Scheme': 'internet-facing',
                'Type': 'application',
                'Subnets': [
                    {'Ref': f'{project_name}PublicSubnet1'},
                    {'Ref': f'{project_name}PublicSubnet2'}
                ],
                'SecurityGroups': [{'Ref': f'{project_name}SecurityGroup'}],
                'Tags': [
                    {'Key': 'Name', 'Value': {'Fn::Sub': '${ProjectName}-ALB'}}
                ]
            }
        }
    }

def _generate_cloudfront_resources(project_name: str) -> Dict[str, Any]:
    """Generate CloudFront resources"""
    return {
        f'{project_name}CloudFrontDistribution': {
            'Type': 'AWS::CloudFront::Distribution',
            'Properties': {
                'DistributionConfig': {
                    'Origins': [
                        {
                            'Id': 'S3Origin',
                            'DomainName': {'Fn::GetAtt': [f'{project_name}S3Bucket', 'DomainName']},
                            'S3OriginConfig': {
                                'OriginAccessIdentity': ''
                            }
                        }
                    ],
                    'DefaultCacheBehavior': {
                        'TargetOriginId': 'S3Origin',
                        'ViewerProtocolPolicy': 'redirect-to-https',
                        'AllowedMethods': ['GET', 'HEAD'],
                        'CachedMethods': ['GET', 'HEAD'],
                        'ForwardedValues': {
                            'QueryString': False,
                            'Cookies': {'Forward': 'none'}
                        }
                    },
                    'Enabled': True,
                    'Comment': {'Fn::Sub': '${ProjectName} CloudFront Distribution'}
                }
            }
        }
    }

def _generate_data_analytics_resources(project_name: str) -> Dict[str, Any]:
    """Generate resources for data analytics solutions"""
    return {
        f'{project_name}DataLakeS3': {
            'Type': 'AWS::S3::Bucket',
            'Properties': {
                'BucketName': {'Fn::Sub': '${ProjectName}-datalake-${Environment}-${AWS::AccountId}'},
                'VersioningConfiguration': {'Status': 'Enabled'},
                'BucketEncryption': {
                    'ServerSideEncryptionConfiguration': [
                        {'ServerSideEncryptionByDefault': {'SSEAlgorithm': 'AES256'}}
                    ]
                }
            }
        }
    }

def _generate_iot_resources(project_name: str) -> Dict[str, Any]:
    """Generate resources for IoT solutions"""
    return {
        f'{project_name}IoTThing': {
            'Type': 'AWS::IoT::Thing',
            'Properties': {
                'ThingName': {'Fn::Sub': '${ProjectName}-IoT-Device'}
            }
        }
    }

def _generate_general_enterprise_resources(project_name: str) -> Dict[str, Any]:
    """Generate general enterprise resources"""
    resources = {}
    resources.update(_generate_ec2_resources(project_name))
    resources.update(_generate_rds_resources(project_name))
    resources.update(_generate_s3_resources(project_name))
    return resources
